; Test script for ruse.

; Features required TODO:
; * Rule env must include future rules in same scope.
; * Quasiquote.
; * Improper lists in match.

(= multiply (quote multiply))

(= (multiply (int @x) (int @y))
	 (multiply-int x x))

(= square (quote square))

(= (square (@t @x))
	 (multiply (t x) (t x)))

;(square (int 8))
;(cond
;	((builtin eq? 'dog 'dog) (int 1))
;	(else (int 0)))

(=* (if @c @t @f)
		(cond (c t) (else f)))

;(if (builtin eq? 1 1)
;	(int 1)
;	(int 0))

;(apply-rules square (int 5))

(= record 'record)
(= (record @packer @fields)
	 (builtin list packer fields))

(= contiguous-packer 'contiguous-packer)

(= packing-field-pop 'packing-field-pop)
(= packing-field-push 'packing-field-push)
(= packing-padding-pop 'packing-padding-pop)
(= packing-padding-push 'packing-padding-push)

(= (packing-padding-pop contiguous-packer (buffer-pos-ref (@buf @pos)) @type @fields-tail)
	 (tag buffer-pos-ref (list buf pos)))
(= (packing-field-pop contiguous-packer (buffer-pos-ref (@buf @pos)) @type @fields-tail)
	 (tag buffer-pos-ref (builtin list buf (- (int pos) (sizeof type)))))
(= (packing-padding-push contiguous-packer (buffer-pos-ref (@buf @pos)) @type @fields-tail)
	 (tag buffer-pos-ref (list buf pos)))
(= (packing-field-push contiguous-packer (buffer-pos-ref (@buf @pos)) @type @fields-tail)
	 (tag buffer-pos-ref (builtin list buf (+ (int pos) (sizeof type)))))

(= (packing-push @packer @ref @type @fields-tail)
	 (packing-field-push packer (packing-padding-push packer ref type fields-tail) type fields-tail))
(= (packing-pop @packer @ref @type @fields-tail)
	 (packing-padding-pop packer (packing-field-pop packer ref type fields-tail) type fields-tail))

; Record.
(= (get
		 (record
			 (buffer-record-rep @packer)
			 (field-list ((@name @type) . @fields-tail)))
		 @name-req
		 @record-ref)

	 ; Recursively search for the field with the specified name.
	 (block
		 (= ref record-ref)
		 (= recurse 'recurse)
		 (= (recurse ((@cur-name @cur-type) . @cur-fields-tail))
				(block
					(recurse cur-fields-tail)
		 (= (recurse ((!name @cur-type) . @cur-fields-tail))
				(get type record-ref))
		 (= (recurse ())
				(error "Record has no member \"~a\" name))))

; Name-mismatch case.
(= (get
		 (record
			 (buffer-record-rep @packer)
			 (field-list ((@name @type) . @fields-tail)))
		 @name-req
		 @field-list-ref)
	 (get (record (buffer-record-rep packer) (field-list fields-tail)) name-req
				(packing-pop packer field-list-ref type fields-tail)))

; Name match case.
(= (get
		 (record
			 (buffer-record-rep @packer)
			 (field-list ((@name @type) . @fields-tail)))
		 @name
		 @field-list-ref)
	 (get type field-list-ref))

; Base case.
(= (get
		 (record
			 (buffer-record-rep @packer)
			 (field-list ()))
		 @name-req
		 @field-list-ref)
	 (error "Record has no member \"~a\" name-req))

(= (sizeof 
		 (record
			 (buffer-record-rep @packer)
			 (field-list @fields)))

	 ; Calculate the size by creating a dummy reference and packing
	 ; all the fields into it, then returning the position at the end.
	 (block
		 (= dummy-ref (buffer-pos-ref (null 0)))
		 (= recurse 'recurse)
		 (= (recurse ((@name @type) . @fields-remaining))
				(block
					(recurse fields-remaining)
					(set dummy-ref (packing-push packer dummy-ref type fields-remaining))))
		 (= (recurse ())
				null)
		 (recurse fields)
		 (packing-push packer dummy-ref void fields)
		 (get dummy-ref pos)))

(= (construct
		 (record
			 (buffer-record-rep @packer)
			 (field-list @fields))
		 @ref)

	 ; Recursively construct all the fields, starting with the tail of the list.
	 (block
		 (= recurse 'recurse)
		 (= (recurse ((@name @type) . @fields-remaining) @struct-ref)
				(block
					(= field-ref (recurse fields-remaining struct-ref))
					(construct type field-ref)

;(= test-record (record
(get test-record 'test-field)
